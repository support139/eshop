Глава 1. Введение
Что такое Subversion?
Subversion — это свободная система управления версиями с открытым исходным кодом. Subversion позволяет управлять файлами и каталогами во времени. Дерево файлов помещается в центральное хранилище, которое похоже на обычный сервер файлов с тем отличием, что оно запоминает каждое изменение, внесённое в файл или каталог. Это позволяет восстановить ранние версии данных, исследовать историю изменений данных. Благодаря этому, многие считают систему управления версиями своеобразной «машиной времени».
Subversion обращается к хранилищу по сети, что позволяет использовать её на разных компьютерах. Возможность совместной работы с одним и тем же набором данных поощряет сотрудничество. При отсутствии единственного контролирующего звена, через которое должны проходить все изменения, работа становится более эффективной. При этом не нужно опасаться, что отказ от контролирующего звена повлияет на качество, ведь благодаря сохранению истории версий, даже если в данные будут внесены ошибочные изменения, всегда можно сделать откат изменений к прежнему состоянию.
Subversion представляет собой систему общего назначения, которую можно использовать для управления любым набором файлов. Ваши файлы могут быть исходным кодом, а для кого-то это будет что-то иное, например списки покупок в продовольственном магазине или сведённые цифровые видеоролики.
История Subversion
В начале 2000 года компания CollabNet, Inc. решила начать разработку программного обеспечения, призванного прийти на смену CVS, и стала искать людей, способных решить эту задачу. CollabNet предлагает комплекс программных средств для совместной работы, одним из компонентов которого является средство для управления версиями. В качестве такого средства использовалась CVS, хотя её недостатки были очевидны с самого начала, и для CollabNet было ясно, что рано или поздно придётся искать замену. К сожалению, CVS стала стандартом де-факто в мире программного обеспечения с открытым исходным кодом, главным образом потому, что ничего лучшего в то время не существовало, по крайней мере среди программ со свободной лицензией. И тогда CollabNet решила написать новую систему управления версиями с нуля, сохранив основные идеи CVS, но без ошибок и неудобств, присущих CVS.
В феврале 2000 года CollabNet связалась с автором книги Open Source Development with CVS Карлом Фогелем [Karl Fogel] и предложила ему принять участие в этом новом проекте. Интересно, что Карл тогда уже обсуждал проект новой системы управления версиями со своим другом Джимом Блэнди [Jim Blandy]. Работодатель Джима, RedHat Software, пожертвовал своим сотрудником для нового проекта, предоставив ему возможность работать над Subversion в течение неограниченного времени. CollabNet взяла на работу Карла и Бена Коллинза-Сассмана [Ben Collins-Sussman], и в мае началась работа по проектированию системы. 
Команда первых инженеров решила остановиться на достижении ряда простых целей: Subversion должна соответствовать CVS по набору возможностей, сохранив ту же самую модель разработки, но без очевидных недостатков CVS. 
И вот, 31 августа 2001 года, спустя четырнадцать месяцев с начала работы, команда прекратила использовать CVS и перешла на Subversion для управления версиями собственного исходного кода — Subversion стала «самодостаточной».
Возможности Subversion
Обсуждать возможности Subversion удобнее всего в разрезе её улучшений по сравнению с CVS. 
Subversion предоставляет следующие возможности:
Управление версиями каталогов
CVS следит только за историей отдельных файлов, тогда как Subversion использует «виртуальную» файловую систему с возможностями управления версиями, которая способна отслеживать изменения во времени целых деревьев каталогов. Под управление версиями попадают файлы и каталоги.
Настоящая история версий
CVS ограничивается управлением версиями файлов, поэтому такие операции, как копирование и переименование, хотя и относящиеся к файлам, но по существу являющиеся изменениями каталогов, содержащих эти файлы, в CVS не поддерживаются. Кроме того, в CVS вы не можете заменить файл, помещённый под управление версиями, другим файлом с тем же именем, но совершенно иным содержанием, возможно никак не связанным со старым объектом, без наследования таким элементом всей истории изменений. Subversion делает возможным добавление, удаление, копирование и переименование как файлов, так и каталогов. При этом каждый вновь добавленный файл начинает жизнь с чистого листа, сохраняя собственную историю изменений.
Атомарные закрепления изменений (true atomic commits)
Каждый набор изменений либо попадает в хранилище целиком, либо не попадает туда вовсе. Это позволяет разработчикам создавать и закреплять изменения логически оправданными кусками, предотвращая тем самым проблемы, которые могут возникать в тех случаях, когда только часть необходимых изменений помещается в хранилище успешно.
Метаданные с версиями
Каждый файл и каталог имеет собственный набор свойств, представленных в виде названия и значения. Вы можете создавать и сохранять любые необходимые пары названий свойств и их значений. Свойства файлов точно так же находятся под управлением версиями, как и их содержимое.
Выбор средств доступа к хранилищу по сети
В Subversion используется абстракция доступа к хранилищу, что позволяет реализовывать самые разные сетевые механизмы доступа. Subversion может быть подключена к серверу HTTP Apache в виде модуля, что даёт ей огромное преимущество с точки зрения устойчивости работы и способности к взаимодействию, а также предоставляет прямой доступ к существующим возможностям этого сервера, включая установление личности, проверку прав доступа и сжатие информации при передаче. Кроме того, имеется лёгкий самостоятельный сервер Subversion, который использует собственный протокол взаимодействия с клиентами и может легко туннелировать данные через SSH.
Единый способ работы с данными
Subversion обнаруживает различия между файлами с помощью специального бинарного алгоритма, который одинаково работает как с текстовыми, так и с бинарными файлами. Файлы записываются в хранилище в сжатом виде независимо от их типа, а различия между отдельными версиями могут передаваться по сети в обоих направлениях.
Эффективные ветки и метки
Плата за использование веток и меток не должна быть пропорциональна размеру проекта. Subversion создаёт ветки и метки путём простого копирования проекта, но никаких копий файлов не создается: используется механизм, похожий на жёсткие ссылки в файловых системах. Благодаря этому, операции по созданию веток и меток занимают немного времени. 
Дружелюбность по отношению к разработчикам
Subversion не имеет исторического багажа. Она реализована в виде набора динамических библиотек на языке C, API которых хорошо известен. Это делает Subversion чрезвычайно удобной для сопровождения системой, пригодной для взаимодействия с другими приложениями и языками программирования.
Архитектура Subversion
Общий взгляд на устройство Subversion показан на рисунке 1, «Архитектура Subversion».
На одной стороне схемы изображено хранилище Subversion, в котором хранится информация с версиями. На противоположной стороне показана программа-клиент Subversion, которая управляет локальными отражениями различных фрагментов этих данных (также называемыми «рабочими копиями»). Между этими сторонами проложены различные маршруты, проходящие через разные слои доступа к хранилищу. Некоторые из этих маршрутов используют компьютерные сети и сетевые сервера, чтобы достичь хранилища, в то время как другие маршруты в сети не нуждаются и ведут к хранилищу напрямую.
Глава 2. Основные понятия
Хранилище (репозиторий)
Subversion является централизованной системой для разделения информации. В ее основе хранилище, являющееся центром хранения данных. Хранилище хранит информацию в форме дерева файлов — типичном представлении файлов и каталогов. Любое количество клиентов подключается к хранилищу и читает или записывает эти файлы. Записывая данные, клиент делает информацию доступной для остальных; читая данные клиент получает информацию от других. Рисунок 2.1, «Типичная клиент/серверная система» иллюстрирует это.
Почему мы заостряем на этом внимание? Пока это звучит как определение типичного файл-сервера. И действительно, хранилище является разновидностью файл-сервера, однако не совсем обычного. Что делает хранилище Subversion особенным — это то, что он запоминает каждое внесенное изменение: любое изменение любого файла, равно как изменения в самом дереве каталогов, такие как добавление, удаление и реорганизация файлов и каталогов.
При чтении данных из хранилища клиент обычно видит только последнюю версию дерева файлов. Но клиент также имеет возможность просмотреть предыдущие состояния файловой системы. Например, клиент может запросить такие данные как, «Что содержал этот каталог в прошлую среду?» или «Кто был последним изменявшим этот файл и какие вносились изменения?» Вопросы подобного типа основные для любой системы контроля версий: системы разработанной для записи и отслеживания изменений информации во времени. 
URL хранилища
Получить доступ к хранилищу Subversion можно различными способами — на локальном диске или через ряд сетевых протоколов. Местоположение хранилища всегда определяется при помощи URL. Таблица Таблица 2.1, «URL для доступа к хранилищу» показывает соответствие разных URL-схем возможным методам доступа.
Модели версионирования
Основной задачей системы управления версиями является обеспечение совместного редактирования и распределения информации. Однако разные системы используют разные способы для достижения этого.
Проблема разделения файлов
Всем системам контроля версий приходится решать одну и ту же основную проблему: как предоставить пользователям возможность совместного использования информации, при этом, не позволяя им наступать друг другу на пятки? Пользователи могут просто непреднамеренно перезаписать в хранилище изменения друг друга.
Допустим у нас есть два разработчика Дима и Леша. Они вдвоем решили одновременно поредактировать один и тот же файл из хранилища. Если первым свои изменения в хранилище сохранит Дима, то, возможно, что (несколькими минутами позже) Леша может непреднамеренно перезаписать их своей новой версией файла. Несмотря на то, что версия файла Димы не будет полностью потеряна (так как система помнит каждое изменение) внесенные Димой изменения не будут отражены в новой версии файла Леши, потому что при сохранении файла Лешей не учитывались изменения Димы. Работа Димы фактически потеряна — или, по крайней мере, отсутствует в последней версии файла — по случайности. Как раз этой ситуации мы и хотим избежать!
Модель Блокирование-Изменение-Разблокирование
Многие системы управления версиями применяют в отношении этой проблемы модель блокирование-изменение-разблокирование. В такой системе хранилище разрешает изменение файла только одному человеку в каждый из моментов времени. До того как Дима сможет внести изменения он должен «заблокировать» файл. Блокирование файла это как взятие книги в библиотеке; если Дима заблокировал файл, то Леша ни как не сможет его изменить. Хранилище отклонит запрос, если он попытается заблокировать файл. Все что ей остается — это читать файл и ждать когда Дима закончит свои изменения и снимет блокировку. После того как Дима разблокирует файл, он возвращает его обратно и теперь Леша может получить его, заблокировать и редактировать. 
Проблемой модели блокирование-изменение-разблокирование является то, что она немного ограниченная и часто доставляет неудобства пользователям:
•	Блокирование может вызвать проблемы администрирования. Иногда Дима заблокирует файл, а затем забудет об этом. Между тем, ожидая редактирования файла, у Леши будут связаны руки. А Дима уехал в отпуск. Теперь Леше, для снятия блокировки Димы, нужно обращаться к администратору. Ситуация заканчивается не нужной задержкой и потерянным временем.
•	Блокирование может вызвать излишнюю пошаговость. Что если Дима редактирует начало текстового файла, а Леше нужно отредактировать концовку этого же файла? Эти изменения совсем не перекрываются. Они могли бы легко редактировать файл одновременно и никаких особенных проблем это не вызвало бы, предполагая корректное слияние изменений. Блокирование файла в такой ситуации не требуется.
•	Блокирование может вызвать ложное чувство безопасности. Предположим, что Дима блокирует и редактирует файл А, в то время как Леша одновременно блокирует и редактирует файл В. Но допустим, что А и В зависят друг от друга и сделанные в каждом изменения семантически не совместимы. Получается так, что А и В больше не работают вместе. Блокирующая система бессильна в предотвращении проблемы — вместо этого она обеспечила ложное чувство безопасности. Для Димы и Леши просто вообразить, что, блокируя файлы, каждый начинает безопасную изолированную задачу и не беспокоиться в начале об обсуждении их несовместимых изменений.
Модель Копирование-Изменение-Слияние
Subversion, CVS и другие системы управления версиями пользуются моделью копирование-изменение-слияние в качестве альтернативы блокированию. В этой модели каждый пользовательский клиент связывается с хранилищем проекта и создает персональную рабочую копию — локальное отражение файлов и каталогов хранилища. После этого пользователи работают параллельно, изменяя свои личные копии. В конце концов, личные копии сливаются в новую, финальную версию. Обычно система управления версиями помогает в слиянии, но, разумеется, за его корректное выполнение отвечает человек.
Вот пример. Скажем и Дима и Леша создали копированием из хранилища рабочие копии одного и того же проекта. Они работают одновременно, и в своих рабочих копиях вносят изменения в один и тот же файл А. Первым свои изменения в хранилище сохраняет Леша. Когда позже Дима попытается сохранить свои изменения, хранилище проинформирует его о том, что его файл А устарел. Другими словами, файл А каким то образом изменился со времени, когда он его последний раз копировал. Поэтому Дима просит свой клиент слить любые изменения из хранилища с его рабочей копией файла А. По счастливому совпадению, изменения Леши не перекрываются с его собственными; после объединения обоих наборов изменений он сохраняет свою рабочую копию обратно в хранилище. 
А что если изменения Леши перекрываются с изменениями Димы? Что тогда? Эта ситуация называется конфликтом и, как правило, это не является большой проблемой. Когда Дима просит свой клиент слить последние изменения хранилища со своей рабочей копией, его копия файла А неким образом помечается как находящаяся в состоянии конфликта: у него будет возможность видеть оба набора конфликтующих изменений и вручную сделать между ними выбор. Помните, что ПО не может автоматически разрешать конфликты; только человек способен к пониманию и выполнению осмысленного выбора. Разрешив вручную перекрывающиеся изменения — возможно, после обсуждения с Лешей — он может безопасно сохранить объединенный файл обратно в хранилище.
Модель копирование-изменение-слияние может выглядеть немного хаотично, однако, на практике она отлично работает. Пользователи могут работать параллельно, не тратя время на ожидание друг друга. При работе над одними и теми же файлами оказывается, что большинство параллельно вносимых изменений совсем не перекрываются; конфликты бывают редко. И время, которое было потрачено на разрешение конфликтов значительно меньше времени отнимаемого блокирующей системой.
Наконец, все сходится к такому критическому фактору, как взаимодействие пользователей. При плохом взаимопонимании увеличивается количество как синтаксических, так и семантических конфликтов. Нет системы, которая может повысить уровень взаимопонимания, и нет системы, которая может определять семантические конфликты. Не стоит возлагать большие надежды на то, что блокирующая система лучше защищена от конфликтов; на практике блокирование снижает продуктивность как ничто другое.
[!!!] Когда блокирование необходимо [!!!]
Несмотря на то, что модель блокирование-изменение-разблокирование названа, в целом, губительной для командной работы, все-таки есть моменты когда блокирование уместно.
Модель копирование-изменение-слияние основывается на предположении о том, что файлы контекстно-объединяемы: это так если большинство файлов в хранилище — текстовые файлы (например исходный код программы). Но для файлов бинарных форматов, таких как графические или звуковые, как правило не возможно объединить конфликтующие изменения. В таких ситуациях пользователям действительно необходимо быть внимательными при изменении файла. Без раздельного доступа кто-то может впустую потратить время на изменения, которые в конце концов будут потеряны.
Так как и CVS, и Subversion, — в первую очередь системы типа копирование-изменение-слияние, то в них обоих признается необходимость блокирования определенных файлов и предлагаются механизмы для этого. 
Глобальные номера ревизий
В отличие от многих других систем управления версиями, номера ревизий в Subversion относятся ко всем, а не только к отдельно взятым файлам. Каждый номер ревизии соответствует целому дереву, отдельному состоянию хранилища после зафиксированного изменения. Иначе говоря — ревизия N представляет состояние файловой системы хранилища после выполнения N-ой фиксации. Когда пользователи Subversion говорят о «ревизии 5 foo.c», на самом деле речь идет о «foo.c входящем в ревизию 5». Заметьте, что обычно ревизии N и M файла не обязательно будут отличаться.
Рекомендуемая структура хранилища
В отличие от многих других систем управления версиями, в Subversion принята за стандарт следующая структура репозитория:
<project>
	branches — папка, в которой размещаются отдельные ветки разработки проекта
	tags	     — в этой папке обычно хранят замороженные версии кода проекта
	trunk	   — общая ветка разработки проекта, используется до начала подготовки к релизу, в случае же выпуска релиза рекомендуется создавать отдельный брэнч (в папке branches), который после завершения багфиксинга и кодефриза будет скопирован в один из tags).
Подробнее о branches, tags и trunk мы поговорим чуть позднее.
