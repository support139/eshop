Глава 1. Введение
Что такое Subversion?
Subversion — это свободная система управления версиями с открытым исходным кодом. Subversion позволяет управлять файлами и каталогами во времени. Дерево файлов помещается в центральное хранилище, которое похоже на обычный сервер файлов с тем отличием, что оно запоминает каждое изменение, внесённое в файл или каталог. Это позволяет восстановить ранние версии данных, исследовать историю изменений данных. Благодаря этому, многие считают систему управления версиями своеобразной «машиной времени».
Subversion обращается к хранилищу по сети, что позволяет использовать её на разных компьютерах. Возможность совместной работы с одним и тем же набором данных поощряет сотрудничество. При отсутствии единственного контролирующего звена, через которое должны проходить все изменения, работа становится более эффективной. При этом не нужно опасаться, что отказ от контролирующего звена повлияет на качество, ведь благодаря сохранению истории версий, даже если в данные будут внесены ошибочные изменения, всегда можно сделать откат изменений к прежнему состоянию.
Subversion представляет собой систему общего назначения, которую можно использовать для управления любым набором файлов. Ваши файлы могут быть исходным кодом, а для кого-то это будет что-то иное, например списки покупок в продовольственном магазине или сведённые цифровые видеоролики.
История Subversion
В начале 2000 года компания CollabNet, Inc. решила начать разработку программного обеспечения, призванного прийти на смену CVS, и стала искать людей, способных решить эту задачу. CollabNet предлагает комплекс программных средств для совместной работы, одним из компонентов которого является средство для управления версиями. В качестве такого средства использовалась CVS, хотя её недостатки были очевидны с самого начала, и для CollabNet было ясно, что рано или поздно придётся искать замену. К сожалению, CVS стала стандартом де-факто в мире программного обеспечения с открытым исходным кодом, главным образом потому, что ничего лучшего в то время не существовало, по крайней мере среди программ со свободной лицензией. И тогда CollabNet решила написать новую систему управления версиями с нуля, сохранив основные идеи CVS, но без ошибок и неудобств, присущих CVS.
В феврале 2000 года CollabNet связалась с автором книги Open Source Development with CVS Карлом Фогелем [Karl Fogel] и предложила ему принять участие в этом новом проекте. Интересно, что Карл тогда уже обсуждал проект новой системы управления версиями со своим другом Джимом Блэнди [Jim Blandy]. Работодатель Джима, RedHat Software, пожертвовал своим сотрудником для нового проекта, предоставив ему возможность работать над Subversion в течение неограниченного времени. CollabNet взяла на работу Карла и Бена Коллинза-Сассмана [Ben Collins-Sussman], и в мае началась работа по проектированию системы. 
Команда первых инженеров решила остановиться на достижении ряда простых целей: Subversion должна соответствовать CVS по набору возможностей, сохранив ту же самую модель разработки, но без очевидных недостатков CVS. 
И вот, 31 августа 2001 года, спустя четырнадцать месяцев с начала работы, команда прекратила использовать CVS и перешла на Subversion для управления версиями собственного исходного кода — Subversion стала «самодостаточной».
Возможности Subversion
Обсуждать возможности Subversion удобнее всего в разрезе её улучшений по сравнению с CVS. 
Subversion предоставляет следующие возможности:
Управление версиями каталогов
CVS следит только за историей отдельных файлов, тогда как Subversion использует «виртуальную» файловую систему с возможностями управления версиями, которая способна отслеживать изменения во времени целых деревьев каталогов. Под управление версиями попадают файлы и каталоги.
Настоящая история версий
CVS ограничивается управлением версиями файлов, поэтому такие операции, как копирование и переименование, хотя и относящиеся к файлам, но по существу являющиеся изменениями каталогов, содержащих эти файлы, в CVS не поддерживаются. Кроме того, в CVS вы не можете заменить файл, помещённый под управление версиями, другим файлом с тем же именем, но совершенно иным содержанием, возможно никак не связанным со старым объектом, без наследования таким элементом всей истории изменений. Subversion делает возможным добавление, удаление, копирование и переименование как файлов, так и каталогов. При этом каждый вновь добавленный файл начинает жизнь с чистого листа, сохраняя собственную историю изменений.
Атомарные закрепления изменений (true atomic commits)
Каждый набор изменений либо попадает в хранилище целиком, либо не попадает туда вовсе. Это позволяет разработчикам создавать и закреплять изменения логически оправданными кусками, предотвращая тем самым проблемы, которые могут возникать в тех случаях, когда только часть необходимых изменений помещается в хранилище успешно.
Метаданные с версиями
Каждый файл и каталог имеет собственный набор свойств, представленных в виде названия и значения. Вы можете создавать и сохранять любые необходимые пары названий свойств и их значений. Свойства файлов точно так же находятся под управлением версиями, как и их содержимое.
Выбор средств доступа к хранилищу по сети
В Subversion используется абстракция доступа к хранилищу, что позволяет реализовывать самые разные сетевые механизмы доступа. Subversion может быть подключена к серверу HTTP Apache в виде модуля, что даёт ей огромное преимущество с точки зрения устойчивости работы и способности к взаимодействию, а также предоставляет прямой доступ к существующим возможностям этого сервера, включая установление личности, проверку прав доступа и сжатие информации при передаче. Кроме того, имеется лёгкий самостоятельный сервер Subversion, который использует собственный протокол взаимодействия с клиентами и может легко туннелировать данные через SSH.
Единый способ работы с данными
Subversion обнаруживает различия между файлами с помощью специального бинарного алгоритма, который одинаково работает как с текстовыми, так и с бинарными файлами. Файлы записываются в хранилище в сжатом виде независимо от их типа, а различия между отдельными версиями могут передаваться по сети в обоих направлениях.
Эффективные ветки и метки
Плата за использование веток и меток не должна быть пропорциональна размеру проекта. Subversion создаёт ветки и метки путём простого копирования проекта, но никаких копий файлов не создается: используется механизм, похожий на жёсткие ссылки в файловых системах. Благодаря этому, операции по созданию веток и меток занимают немного времени. 
Дружелюбность по отношению к разработчикам
Subversion не имеет исторического багажа. Она реализована в виде набора динамических библиотек на языке C, API которых хорошо известен. Это делает Subversion чрезвычайно удобной для сопровождения системой, пригодной для взаимодействия с другими приложениями и языками программирования.
Архитектура Subversion
Общий взгляд на устройство Subversion показан на рисунке 1, «Архитектура Subversion».
На одной стороне схемы изображено хранилище Subversion, в котором хранится информация с версиями. На противоположной стороне показана программа-клиент Subversion, которая управляет локальными отражениями различных фрагментов этих данных (также называемыми «рабочими копиями»). Между этими сторонами проложены различные маршруты, проходящие через разные слои доступа к хранилищу. Некоторые из этих маршрутов используют компьютерные сети и сетевые сервера, чтобы достичь хранилища, в то время как другие маршруты в сети не нуждаются и ведут к хранилищу напрямую.
Глава 2. Основные понятия
Хранилище (репозиторий)
Subversion является централизованной системой для разделения информации. В ее основе хранилище, являющееся центром хранения данных. Хранилище хранит информацию в форме дерева файлов — типичном представлении файлов и каталогов. Любое количество клиентов подключается к хранилищу и читает или записывает эти файлы. Записывая данные, клиент делает информацию доступной для остальных; читая данные клиент получает информацию от других. Рисунок 2.1, «Типичная клиент/серверная система» иллюстрирует это.
Почему мы заостряем на этом внимание? Пока это звучит как определение типичного файл-сервера. И действительно, хранилище является разновидностью файл-сервера, однако не совсем обычного. Что делает хранилище Subversion особенным — это то, что он запоминает каждое внесенное изменение: любое изменение любого файла, равно как изменения в самом дереве каталогов, такие как добавление, удаление и реорганизация файлов и каталогов.
При чтении данных из хранилища клиент обычно видит только последнюю версию дерева файлов. Но клиент также имеет возможность просмотреть предыдущие состояния файловой системы. Например, клиент может запросить такие данные как, «Что содержал этот каталог в прошлую среду?» или «Кто был последним изменявшим этот файл и какие вносились изменения?» Вопросы подобного типа основные для любой системы контроля версий: системы разработанной для записи и отслеживания изменений информации во времени. 
URL хранилища
Получить доступ к хранилищу Subversion можно различными способами — на локальном диске или через ряд сетевых протоколов. Местоположение хранилища всегда определяется при помощи URL. Таблица Таблица 2.1, «URL для доступа к хранилищу» показывает соответствие разных URL-схем возможным методам доступа.
Модели версионирования
Основной задачей системы управления версиями является обеспечение совместного редактирования и распределения информации. Однако разные системы используют разные способы для достижения этого.
Проблема разделения файлов
Всем системам контроля версий приходится решать одну и ту же основную проблему: как предоставить пользователям возможность совместного использования информации, при этом, не позволяя им наступать друг другу на пятки? Пользователи могут просто непреднамеренно перезаписать в хранилище изменения друг друга.
Допустим у нас есть два разработчика Дима и Леша. Они вдвоем решили одновременно поредактировать один и тот же файл из хранилища. Если первым свои изменения в хранилище сохранит Дима, то, возможно, что (несколькими минутами позже) Леша может непреднамеренно перезаписать их своей новой версией файла. Несмотря на то, что версия файла Димы не будет полностью потеряна (так как система помнит каждое изменение) внесенные Димой изменения не будут отражены в новой версии файла Леши, потому что при сохранении файла Лешей не учитывались изменения Димы. Работа Димы фактически потеряна — или, по крайней мере, отсутствует в последней версии файла — по случайности. Как раз этой ситуации мы и хотим избежать!
Модель Блокирование-Изменение-Разблокирование
Многие системы управления версиями применяют в отношении этой проблемы модель блокирование-изменение-разблокирование. В такой системе хранилище разрешает изменение файла только одному человеку в каждый из моментов времени. До того как Дима сможет внести изменения он должен «заблокировать» файл. Блокирование файла это как взятие книги в библиотеке; если Дима заблокировал файл, то Леша ни как не сможет его изменить. Хранилище отклонит запрос, если он попытается заблокировать файл. Все что ей остается — это читать файл и ждать когда Дима закончит свои изменения и снимет блокировку. После того как Дима разблокирует файл, он возвращает его обратно и теперь Леша может получить его, заблокировать и редактировать. 
Проблемой модели блокирование-изменение-разблокирование является то, что она немного ограниченная и часто доставляет неудобства пользователям:
•	Блокирование может вызвать проблемы администрирования. Иногда Дима заблокирует файл, а затем забудет об этом. Между тем, ожидая редактирования файла, у Леши будут связаны руки. А Дима уехал в отпуск. Теперь Леше, для снятия блокировки Димы, нужно обращаться к администратору. Ситуация заканчивается не нужной задержкой и потерянным временем.
•	Блокирование может вызвать излишнюю пошаговость. Что если Дима редактирует начало текстового файла, а Леше нужно отредактировать концовку этого же файла? Эти изменения совсем не перекрываются. Они могли бы легко редактировать файл одновременно и никаких особенных проблем это не вызвало бы, предполагая корректное слияние изменений. Блокирование файла в такой ситуации не требуется.
•	Блокирование может вызвать ложное чувство безопасности. Предположим, что Дима блокирует и редактирует файл А, в то время как Леша одновременно блокирует и редактирует файл В. Но допустим, что А и В зависят друг от друга и сделанные в каждом изменения семантически не совместимы. Получается так, что А и В больше не работают вместе. Блокирующая система бессильна в предотвращении проблемы — вместо этого она обеспечила ложное чувство безопасности. Для Димы и Леши просто вообразить, что, блокируя файлы, каждый начинает безопасную изолированную задачу и не беспокоиться в начале об обсуждении их несовместимых изменений.
Модель Копирование-Изменение-Слияние
Subversion, CVS и другие системы управления версиями пользуются моделью копирование-изменение-слияние в качестве альтернативы блокированию. В этой модели каждый пользовательский клиент связывается с хранилищем проекта и создает персональную рабочую копию — локальное отражение файлов и каталогов хранилища. После этого пользователи работают параллельно, изменяя свои личные копии. В конце концов, личные копии сливаются в новую, финальную версию. Обычно система управления версиями помогает в слиянии, но, разумеется, за его корректное выполнение отвечает человек.
Вот пример. Скажем и Дима и Леша создали копированием из хранилища рабочие копии одного и того же проекта. Они работают одновременно, и в своих рабочих копиях вносят изменения в один и тот же файл А. Первым свои изменения в хранилище сохраняет Леша. Когда позже Дима попытается сохранить свои изменения, хранилище проинформирует его о том, что его файл А устарел. Другими словами, файл А каким то образом изменился со времени, когда он его последний раз копировал. Поэтому Дима просит свой клиент слить любые изменения из хранилища с его рабочей копией файла А. По счастливому совпадению, изменения Леши не перекрываются с его собственными; после объединения обоих наборов изменений он сохраняет свою рабочую копию обратно в хранилище. 
А что если изменения Леши перекрываются с изменениями Димы? Что тогда? Эта ситуация называется конфликтом и, как правило, это не является большой проблемой. Когда Дима просит свой клиент слить последние изменения хранилища со своей рабочей копией, его копия файла А неким образом помечается как находящаяся в состоянии конфликта: у него будет возможность видеть оба набора конфликтующих изменений и вручную сделать между ними выбор. Помните, что ПО не может автоматически разрешать конфликты; только человек способен к пониманию и выполнению осмысленного выбора. Разрешив вручную перекрывающиеся изменения — возможно, после обсуждения с Лешей — он может безопасно сохранить объединенный файл обратно в хранилище.
Модель копирование-изменение-слияние может выглядеть немного хаотично, однако, на практике она отлично работает. Пользователи могут работать параллельно, не тратя время на ожидание друг друга. При работе над одними и теми же файлами оказывается, что большинство параллельно вносимых изменений совсем не перекрываются; конфликты бывают редко. И время, которое было потрачено на разрешение конфликтов значительно меньше времени отнимаемого блокирующей системой.
Наконец, все сходится к такому критическому фактору, как взаимодействие пользователей. При плохом взаимопонимании увеличивается количество как синтаксических, так и семантических конфликтов. Нет системы, которая может повысить уровень взаимопонимания, и нет системы, которая может определять семантические конфликты. Не стоит возлагать большие надежды на то, что блокирующая система лучше защищена от конфликтов; на практике блокирование снижает продуктивность как ничто другое.
[!!!] Когда блокирование необходимо [!!!]
Несмотря на то, что модель блокирование-изменение-разблокирование названа, в целом, губительной для командной работы, все-таки есть моменты когда блокирование уместно.
Модель копирование-изменение-слияние основывается на предположении о том, что файлы контекстно-объединяемы: это так если большинство файлов в хранилище — текстовые файлы (например исходный код программы). Но для файлов бинарных форматов, таких как графические или звуковые, как правило не возможно объединить конфликтующие изменения. В таких ситуациях пользователям действительно необходимо быть внимательными при изменении файла. Без раздельного доступа кто-то может впустую потратить время на изменения, которые в конце концов будут потеряны.
Так как и CVS, и Subversion, — в первую очередь системы типа копирование-изменение-слияние, то в них обоих признается необходимость блокирования определенных файлов и предлагаются механизмы для этого. 
Глобальные номера ревизий
В отличие от многих других систем управления версиями, номера ревизий в Subversion относятся ко всем, а не только к отдельно взятым файлам. Каждый номер ревизии соответствует целому дереву, отдельному состоянию хранилища после зафиксированного изменения. Иначе говоря — ревизия N представляет состояние файловой системы хранилища после выполнения N-ой фиксации. Когда пользователи Subversion говорят о «ревизии 5 foo.c», на самом деле речь идет о «foo.c входящем в ревизию 5». Заметьте, что обычно ревизии N и M файла не обязательно будут отличаться.
Рекомендуемая структура хранилища
В отличие от многих других систем управления версиями, в Subversion принята за стандарт следующая структура репозитория:
<project>
	branches — папка, в которой размещаются отдельные ветки разработки проекта
	tags	     — в этой папке обычно хранят замороженные версии кода проекта
	trunk	   — общая ветка разработки проекта, используется до начала подготовки к релизу, в случае же выпуска релиза рекомендуется создавать отдельный брэнч (в папке branches), который после завершения багфиксинга и кодефриза будет скопирован в один из tags).
Подробнее о branches, tags и trunk мы поговорим чуть позднее.
Глава 3. Экскурсия по Subversion
Создание рабочей копии
Как правило, работа с хранилищем Subversion начинается с создания рабочей копии проекта. При создании рабочей копии на локальной машине создается копия хранилища. Эта копия содержит HEAD (последнюю ревизию) хранилища, указанного вами в командной строке:
svn checkout https://svnmsq.epam.com/epm-bet/trunk
Хотя в приведенном примере рабочая копия создается на основе корневого каталога, вы можете легко создать рабочую копию на основе подкаталога любой степени вложенности, указав при создании рабочей копии подкаталог в URL:
svn checkout https://svnmsq.epam.com/epm-bet/trunk/test
Примечание:
Subversion очень старается не ограничивать количество типов данных, которые можно поместить под контроль системы. Содержимое файлов и значения свойств хранятся и передаются в бинарном формате. Однако есть ситуации, когда Subversion накладывает некоторые ограничения на хранимую информацию.
Внутри Subversion текст представляется в кодировке UTF-8. Как следствие, некоторые элементы, имеющие «текстовую» сущность, например имена свойств, пути и лог-сообщения, могут содержать только корректные UTF-8 символы. Это частично объясняет необходимость свойства svn:mime-type — файл, не совместимый с UTF-8, необходимо пометить как бинарный. В противном случае Subversion будет пытаться, используя UTF-8, выполнить слияние различий, что, скорее всего, закончится замусориванием файла.
Кроме того, имена путей при WebDAV тразакциях используются как значения XML-атрибутов, также как и в некоторых собственных файлах Subversion. Это значит, что при указании путей могут использоваться только корректные для XML (1.0) символы. Так же при указании путей Subversion запрещает использовать символы TAB, CR и LF, что бы они не повреждали файлы различий и не искжали вывод таких команд как svn log или svn status.
Вам может показаться, что нужно помнить очень много всего, однако на практике эти ограничения не вызывают сложностей. Если ваши локальные установки совместимы с UTF-8 и вы не используете специальных символов при указании путей, то проблем при работе с Subversion у вас не возникнет. Клиент для командной строки немного в этом помогает — он автоматически корректирует недопустимые символы, встречающиеся в набранных URL, «юридически правильными» версиями для внутреннего использования.
Так как Subversion использует модель «копирование-изменение-слияние» вместо модели «блокирование-изменение-разблокирование» вы уже можете начинать вносить изменения в файлы и каталоги своей рабочей копии. Ваша рабочая копия ничем не отличается от любого другого набора файлов на вашей системе. Вы можете редактировать и менять их, перемещать, вы даже можете полностью удалить рабочую копию и забыть о ней.
Но, несмотря на то, что рабочая копия выглядит «как и любой другой набор файлов на вашей системе» вы должны поставить в известность Subversion, если вы будете что-либо реорганизовывать в рабочей копии. Если вы хотите скопировать или переместить элемент в рабочей копии вы должны использовать команду svn copy или svn move вместо аналогичных команд, предлагаемых операционной системой. 
Исключение составляют случаи, когда вы готовы зафиксировать новый файл или каталог, либо внести изменения в один из существующих. Для этих операций вы не обязаны дополнительно извещать Subversion-сервер о своих действиях.
Несмотря на то, что вы конечно можете создать рабочую копию, указав только один аргумент в виде URL хранилища, вы можете после URL хранилища указать каталог. Тогда ваша рабочая копия будет находиться в новом каталоге с указанным вами именем. Например:
svn checkout https://svnmsq.epam.com/epm-bet/trunk myrepo
Эта команда создаст рабочую копию в каталоге с именем myrepo, вместо каталога trunk как мы делали раньше.
Что такое каталог .svn
Каждый каталог в рабочей копии содержит служебную область, подкаталог с названием .svn. Обычно, команды используемые для вывода содержимого каталогов не показывают этот подкаталог, но в любом случае, это очень важный каталог. Что бы вы не делали, не удаляйте или не меняйте ничего в служебной области! Subversion использует ее при управлении рабочей копией.
Простейший рабочий цикл
Subversion имеет множество возможностей, опций и украшательств, но в ежедневной работе используются только некоторые из них. В этом разделе мы пройдемся по наиболее часто выполняемым в течение рабочего дня задачам.
Типичный рабочий цикл выглядит примерно так:
•	Обновление рабочей копии
o	svn update
•	Внесение изменений
o	svn add
o	svn delete
o	svn copy
o	svn move
•	Анализ изменений
o	svn status
o	svn diff
o	svn revert
•	Слияние изменений, выполненных другими, с вашей рабочей копией
o	svn update
o	svn resolved
•	Фиксация изменений
o	svn commit
Обновление рабочей копии
При командной работе над проектом обновление рабочей копии необходимо для получения любых изменений, внесенных с момента вашего последнего обновления другими разработчиками проекта. Используйте svn update для синхронизации вашей рабочей копии с последней ревизией в хранилище:
svn update
В данном случае, кто-то другой зафиксировал изменения в файлах foo.c и bar.c после вашего последнего обновления, и Subversion обновила вашу рабочую копию включив эти изменения.
Рассмотрим выводимую командой svn update информацию чуть подробнее. Когда сервер отправляет изменения в вашу рабочую копию для каждого элемента выводится латинская буква — код, определяющий, какое действие выполнила Subversion для приведения ваше рабочей копии в актуальное состояние:
U foo
Файл foo был Updated — обновлен (получил изменения с сервера).
A foo
Файл или директория foo были Added — добавлены в рабочую копию.
D foo
Файл или директория foo были Deleted — удалены из рабочей копии.
R foo
Файл или директория foo была Replaced — заменена в рабочей копии; это значит, что foo был удален, а новый элемент с таким же именем был добавлен. Не смотря на то, что они могут иметь одинаковое имя, хранилище рассматривает их как разные объекты с отдельной историей.
G foo
Файл foo получил новые изменения из хранилища, однако ваша локальная копия содержит ваши изменения. Либо изменения не пересекаются, либо они точно такие же как ваши локальные изменения поэтому Subversion успешно выполнила merGed — слияние изменений хранилища с файлом.
C foo
Файл foo получил от сервера Conflicting — конфликтующие изменения. Изменения с сервера пересекаются с вашими изменениями фала. Однако паниковать не стоит. Это перекрытие нуждается в разрешении человеком (вами); мы обсудим эту ситуацию позже в этой главе.
Внесение изменений в рабочую копию
Теперь вы можете вносить изменения в рабочую копию. Самый подходящий момент внести нужные изменения (или набор изменений), например, добавление новой возможности, исправление ошибки и т. д. Команды Subversion которыми вы будете здесь пользоваться — это svn add, svn delete, svn copy и svn move. Однако если вы просто редактируете файлы которые уже в Subversion ни одна из этих команд вам не нужна. Изменения которые вы можете сделать в вашей рабочей:
•	Изменения файлов
Это самый простой вид изменений. Вам не нужно сообщать Subversion о своем намерении изменить файл; просто берите и вносите изменения. Subversion сможет автоматически определить измененные файлы.
•	Изменения в структуре
Вы можете попросить Subversion «отметить» файлы и директории для удаления, добавления, копирования или перемещения. Не смотря на то, что эти изменения сразу же отразятся в рабочей копии, ни добавления, ни удаления не произойдут в хранилище пока вы их не зафиксируете.
Для внесения изменений в файлы используете свой текстовый редактор, текстовый процессор, графическую программу или любой другой инструмент который вы обычно используете. Subversion обрабатывает бинарные файлы так же легко как и текстовые - и настолько же эффективно.
Для изменения структуры рабочей копии используйте команды svn copy, svn delete и svn move, а для добавления новых файлов и директорий под контроль версий используйте svn add.
Вот обзор четырех подкоманд Subversion которые вы будете использовать наиболее часто при внесении изменений в структуру (команды svn import и svn mkdir мы рассмотрим позже).
svn add foo
Запланировать файл, директорию или символьную ссылку foo для добавления в хранилище. При следующей фиксации (коммите), foo станет компонентом своей родительской директории. Обратите внимание на то, что если foo является директорией, то все содержащееся в foo будет запланировано для добавления. Если вы хотите добавить отдельно foo воспользуйтесь параметром --non-recursive (-N).
svn delete foo
Запланировать удаление из хранилища файла, директории или символьной ссылки foo. Если foo является файлом или ссылкой, он сразу же удаляется из вашей рабочей копии. Если foo является директорией, она не удаляется, но Subversion запланирует ее удаление. foo будет удалена из рабочей копии и хранилища при фиксации изменений.
svn copy foo bar
Создать новый элемент bar как копию foo. bar будет автоматически запланирован для добавления. Когда при следующей фиксации bar будет добавлен в хранилище в его истории будет отмечено копирование (то, что первоисточником является foo). svn copy не создает промежуточных директорий.
svn move foo bar
Эта команда полностью аналогична выполнению svn copy foo bar; svn delete foo. Поэтому, bar будет запланирован для добавления как копия foo, а foo будет запланирован для удаления. svn move не создает промежуточных директорий. 

Изменение хранилища без участия рабочей копии
Ранее в этой главе мы сказали, что вам необходимо зафиксировать любые изменения для того, что бы они отразились в хранилище. Это не совсем так — существуют некоторые случаи использования, которые сразу же фиксируют в хранилище изменения структуры. Это происходит только тогда когда подкоманда оперирует напрямую с URL вместо рабочей копии. В частности, отдельные применения svn mkdir, svn copy, svn move и svn delete могут работать с URL.
URL операции ведут себя подобным образом из-за того, что команды использующие рабочую копию могут использовать ее как своего рода «сартовую площадку» для устаканивания изменений перед фиксацией их в хранилище. Команды оперирующие URL не могут позволить такой роскоши, поэтому, когда вы работаете напрямую с URL, любое из приведенных выше действий приводит к немедленной фиксации.
Анализ изменений
После внесения изменений вам необходимо зафиксировать их в хранилище, но перед тем, как вы это сделаете, не плохо бы посмотреть, что, собственно, вы изменили. Проанализировав перед фиксацией свои изменения, вы сможете составить более аккуратное лог-сообщение. Кроме того, вы можете обнаружить, что вы изменили файл непреднамеренно и это даст вам возможность до фиксации вернуть файл к предыдущему состоянию. К тому же, это хорошая возможность пересмотреть и проверить изменения перед их публикацией. Что бы увидеть все сделанные изменения вы можете воспользоваться svn status, svn diff и svn revert. Первые две команды вы можете использовать для того, что бы найти измененные файлы рабочей копии, а затем при помощи третьей, возможно, отменить некоторые (или все) изменения.
Subversion была оптимизирована для решения такой задачи и способна выполнять множество действий без обращения к хранилищу. В частности, в .svn-области рабочая копия содержит скрытую кешированую «нетронутую» копию каждого версионированного файла. Вследствие этого, Subversion может быстро показать, как изменились ваши рабочие файлы или даже предоставить, не связываясь с хранилищем, возможность сделать откат изменений.
svn status
Наверное, команду svn status вы будете использовать чаще чем любую другую команду Subversion.
При запуске svn status без параметров в корневой директории рабочей копии, будут найдены все сделанные вами файловые и структурные изменения. 
svn status печатает пять колонок букв, затем несколько пробелов, затем имя файла или директории. Первая колонка показывает статус файла или директории и/или ее содержимого. Коды используемые здесь:
A item
Файл, директория или символьная ссылка item была запланирована для добавления в хранилище.
C item
Файл item находится в состоянии конфликта. Это значит, что изменения, полученные от сервера при обновлении пересекаются с локальными изменениями имеющимися в рабочей копии. Перед фиксацией изменений вам необходимо разрешить этот конфликт.
D item
Файл, директория или символьная ссылка item запланированы для удаления из хранилища.
M item
Содержимое файла item было изменено.
R item
Файл, директория или символьная ссылка запланированы для замены item в хранилище. Это значит, что сначала объект был удален, а затем другой объект с таким же именем был добавлен, все в одной ревизии.
X item
Директория item не версионирована, но относится к внешним зависимостям Subversion. 
? item
Файл, директория или символьная ссылка не находится под контролем версий. Вы можете убрать знаки вопроса либо воспользовавшись параметром --quiet (-q) команды svn status, либо установив свойство svn:ignore родительской директории. 
! item
Файл, директория или символьная ссылка item находится под контролем версий но отсутствует или повреждена как-то по другому. Элемент может отсутствовать если был удален используя не-Subversion команды. В случае если это директория, она может оказаться поврежденной, если вы прервали создание рабочей копии или обновление. Быстрый запуск svn update заново вытащит файл или директорию из хранилища, либо svn revert file восстановит отсутствующий файл.
~ item
Файл, директория или символьная ссылка item в хранилище является объектом одного типа, а то, что на самом деле находится в рабочей копии является чем-то другим. Например, в хранилище Subversion может иметь файл, а вы удалили файл и создали вместо него директорию, без использования команды svn delete или svn add.
I item
Файл, директория или символьная ссылка item находится под контролем версий и Subversion настроена на его игнорирование при операциях svn add, svn import и svn status. Обратите внимание на то, что этот символ появляется при использовании опции --no-ignore для svn status — иначе файл игнорируется и не показывается вообще!
Вторая колонка показывает статус свойств файлов и директорий. Если во второй колонке показывается M свойства были изменены, иначе печатается пробел.
Третья колонка может содержать только пробел или L, это значит, что у директории заблокирована рабочая область .svn. Вы увидите L если запустите svn status в директории, в которой выполняется svn commit — например, когда вы редактируете лог-сообщение.
Четвертая колонка может содержать только пробел или +, это означает, что элемент был запланирован для «добавления с историей». Это может быть файл или корень скопированной директории. + означает, что элемент является частью поддерева запланированного для «добавления с историей», т. е. одна из родительских директорий была скопирована и этот элемент просто ее часть. M  + означает, что элемент является частью поддерева запланированного для «добавления с историей» and имеет локальные изменения. При выполнении фиксации, в начале родительская директория будет «добавлена с историей», что означает автоматическое наличие файла в копии. После этого в копию будут загружены локальные изменения.
Пятая колонка может содержать только пробел или S. Это символизирует то, что файл или директория были переключены с пути остальной рабочей копии на ветку (используя svn switch). 
Шестая колонка показывает информацию о блокировке.
Если вы укажите конкретный путь для svn status, вы получите информацию только об этом элементе.
Кроме того, svn status имеет параметр --verbose (-v), который покажет вам статус каждого элемента в рабочей копии, даже если он не менялся. Это «длинная форма» представления вывода svn status. Первая колонка та же самая, а вот вторая колонка показывает рабочую ревизию элемента. Третья и четвертая колонки показывают ревизию в которой элемент последний раз изменялся и кто делал эти изменения.
Ни один из указанных выше вызовов svn status не обращается к хранилищу, они работают только локально, сравнивая метаданные директории .svn с рабочей копией. 
svn diff
Еще один механизм для анализа изменений, это команда svn diff. Увидеть как именно вы изменили элементы можно запустив svn diff без аргументов, в результате выведутся изменения файлов в виде единого формата представления различий.
Команда svn diff формирует свой вывод сравнивая ваши рабочие файлы с кэшированными «нетронутыми» копиями из .svn Весь текст запланированных для добавления файлов показывается как добавленный, а весь текст запланированных для удаления файлов показывается как удаленный.
Вывод происходит в объединенном формате представления различий. При этом удаленные строки предваряются -, а добавленные строки предваряются +. Кроме этого svn diff печатает имена файлов и информацию о сдвиге информации которая необходима программе patch, и следовательно вы можете получать «патчи» перенаправив вывод различий в файл:
svn diff > patchfile
Вы можете, например, отправить по электронной почте патч-файл другому разработчику для ознакомления или тестирования перед фиксацией.
svn revert
Теперь предположим, просмотрев вывод команды diff вы обнаружили, что изменения в README являются ошибочными; возможно, в своем редакторе, вы случайно набрали этот текст, предназначавшийся для другого файла.
Это как раз возможность воспользоваться svn revert.
svn revert README
Subversion возвращает файл в состояние, предшествующее модификации, путем замены файла его кэшированной «первоначальной» копией из .svn-области. Кроме того, обратите внимание, что svn revert может отменить любые запланированные операции — например, вы можете прийти к решению таки не добавлять новый файл.
Все эти три команды (svn status, svn diff и svn revert) могут использоваться при полном отсутствии сетевого доступа. Это позволяет легко управлять рабочими изменениями когда вы находитесь там где нет сетевого соединения, например, находясь в самолете, едучи в пригородном поезде или занимаясь хакерством на пляже.
Для этого Subversion использует отдельную для каждого версионированного файла кэшированную в административной области .svn первоначальную версию. Это позволяет Subversion показывать — и отменять — локальные изменения таких файлов без необходимости сетевого доступа. Этот кеш (называемый «текстовой базой»), кроме всего прочего, позволяет Subversion при фиксации отправлять локальные пользовательские изменения в виде сжатой дельты (или «различий») первоначальной версии. Наличие такого кеша ужасно выгодно — даже если у вас высокоскоростное соединение намного быстрее отправлять на сервер только изменения файла вместо отправки целого файла. На первый взгляд это может показаться не таким уж и важным, но представьте себе последствия, если вы попытаетесь зафиксировать изменения в одной строчке для файла размером 400MБ и отправите на сервер весь файл!

Решение конфликтов (при объединении с чужими изменениями)
Мы уже видели как svn status -u может предсказать конфликты. Предположим вы запустили svn update и произошло кое-что интересное:
$ svn update
U  INSTALL
G  README
C  bar.c
Updated to revision 46.
Коды U и G интереса не представляют; эти файлы без проблем поглотили изменения из хранилища. Файлы, отмеченные U локальных изменений не содержат и были Updated - обновлены изменениями из хранилища. Отмеченные G были merGed - слиты, это значит, что файл имел локальные изменения, но изменения, пришедшие из хранилища, не перекрываются с локальными изменениями.
А вот отмеченные C имеют конфликт. Это значит, что изменения с сервера пересеклись с вашими личными и теперь вам нужно вручную сделать между ними выбор.
Всякий раз когда возникает конфликт, для того, чтобы помочь вам заметить и решить этот конфликт, возникают как правило три вещи:
•	Subversion печатает C во время обновления и запоминает, что файл в состоянии конфликта.
•	Если Subversion считает, что файл объединяемого типа она помещает маркеры конфликта — специальные текстовые строки которые отделяют «стороны» конфликта — в файл, для того, чтобы визуально показать пересекающиеся области. 
•	Для каждого конфликтного файла Subversion добавляет в рабочую копию до трех не версионированных дополнительных файлов:
filename.mine
Это ваш файл в том виде в каком он был в рабочей копии до обновления — без маркеров конфликта. Этот файл содержит в себе только ваши изменения и ничего больше. (Если Subversion решает, что файл не объединяемый, тогда файл .mine не создается, так как он будет идентичным рабочему файлу.)
filename.rOLDREV
Это файл ревизии BASE, где BASE - ревизия которая была до обновления рабочей копии. То есть это файл который у вас был до внесения изменений.
filename.rNEWREV
Это файл, который ваш Subversion-клиент только что получил с сервера, когда вы обновили рабочую копию. Этот файл соответствует ревизии HEAD хранилища.
Здесь OLDREV - это номер ревизии файла в директории .svn, а NEWREV - это номер ревизии HEAD хранилища.
Например, Леша внес изменения в файл sandwich.txt из хранилища. Дима одновременно изменил файл в своей рабочей копии и зафиксировал его. Леша обновляет свою рабочую копию перед фиксацией и получает конфликт:
$ svn update
C  sandwich.txt
Updated to revision 2.
$ dir
sandwich.txt
sandwich.txt.mine
sandwich.txt.r1
sandwich.txt.r2
Теперь Subversion не позволит зафиксировать файл sandwich.txt пока не будут удалены три временных файла.
$ svn commit --message "Add a few more things"
svn: Commit failed (details follow):
svn: Aborting commit: '/home/sally/svn-work/sandwich.txt' remains in conflict
Если вы получили конфликт, у вас есть три варианта:
•	Объединить конфликтующий текст «вручную» (путем анализа и редактирования маркеров конфликта в файле).
•	Скопировать один из временных файлов поверх своего рабочего файла.
•	Выполнить svn revert <filename> для того, чтобы убрать все ваши локальные изменения.
После того, как вы решили конфликт, вам нужно поставить в известность Subversion, выполнив svn resolved. Это удаляет три временных файла и Subversion больше не считает, что файл находится в состоянии конфликта.
$ svn resolved sandwich.txt
Resolved conflicted state of 'sandwich.txt'
Теперь вы готовы к фиксации изменений. Обратите внимание на то, что svn resolved, в отличие от большинства команд с которыми мы имели дело в этой главе, требует аргумент. В любом случае будьте осторожны и выполняйте svn resolved тогда, когда убеждены, что исправили конфликт в файле — после того как временные файлы будут удалены, Subversion позволит вам зафиксировать файл даже если он все еще содержит маркеры конфликта.
Фиксация изменений
Команда svn commit отправляет все ваши изменения в хранилище. При фиксации изменений необходимо указать описывающие ваши изменения лог сообщение. Лог сообщение будет присоединено к созданной ревизии. Если ваше лог сообщение короткое, вы можете указать его в командной строке, используя опцию --message (или -m):
svn commit --message "Corrected number of cheese slices."
Однако, если вы составляли лог сообщение во время работы, можно указать Subversion взять лог сообщение из файла, передавая имя файла в параметре --file:
svn commit --file logmsg
Если вы не укажите ни опции --message ни опции --file, для составления лог сообщения Subversion автоматически запустит ваш любимый редактор.
Если в редакторе набирая сообщение решите отменить фиксацию, вы можете просто выйти из редактора без сохранения изменений. Если вы уже сохранили сообщение, просто удалите текст и выполните сохранение еще раз.
Хранилище, в целом, не знает и не заботится о смысле ваших изменений; оно только контролирует, что бы никто не изменил те же файлы что и вы. Если это все-таки случилось вся фиксация будет отклонена с сообщением информирующим вас, что один или несколько файлов устарели.
Мы рассмотрели простейший рабочий цикл при использовании Subversion. В Subversion существует много других возможностей которые вы можете применять для управления рабочей копией и хранилищем, но с помощью команд, которые мы рассмотрели в этой главе вы уже можете многое сделать.

Анализ истории
Как мы уже говорили, хранилище похоже на машину времени. Оно хранит запись о любом когда-либо зафиксированном изменении и позволяет вам просмотреть его хронологию путем анализа предыдущих версий файлов и директорий, равно как и метаданных присоединенных к ним. Одной командой Subversion вы можете создать рабочую копию (или восстановить существующую) точно в том виде, в котором она была в любой момент времени или номер ревизии в прошлом. Однако, как правило, иногда вам просто нужно заглянуть в прошлое, вместо возвращения в прошлое.

